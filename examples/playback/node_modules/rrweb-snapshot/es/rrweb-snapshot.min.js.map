{"version":3,"file":"rrweb-snapshot.min.js","sources":["../src/types.ts","../src/snapshot.ts","../src/css.ts","../src/rebuild.ts"],"sourcesContent":["export enum NodeType {\n  Document,\n  DocumentType,\n  Element,\n  Text,\n  CDATA,\n  Comment,\n}\n\nexport type documentNode = {\n  type: NodeType.Document;\n  childNodes: serializedNodeWithId[];\n};\n\nexport type documentTypeNode = {\n  type: NodeType.DocumentType;\n  name: string;\n  publicId: string;\n  systemId: string;\n};\n\nexport type attributes = {\n  [key: string]: string | number | boolean;\n};\nexport type elementNode = {\n  type: NodeType.Element;\n  tagName: string;\n  attributes: attributes;\n  childNodes: serializedNodeWithId[];\n  isSVG?: true;\n  needBlock?: boolean;\n};\n\nexport type textNode = {\n  type: NodeType.Text;\n  textContent: string;\n  isStyle?: true;\n};\n\nexport type cdataNode = {\n  type: NodeType.CDATA;\n  textContent: '';\n};\n\nexport type commentNode = {\n  type: NodeType.Comment;\n  textContent: string;\n};\n\nexport type serializedNode =\n  | documentNode\n  | documentTypeNode\n  | elementNode\n  | textNode\n  | cdataNode\n  | commentNode;\n\nexport type serializedNodeWithId = serializedNode & { id: number };\n\nexport type tagMap = {\n  [key: string]: string;\n};\n\nexport interface INode extends Node {\n  __sn: serializedNodeWithId;\n}\n\nexport type idNodeMap = {\n  [key: number]: INode;\n};\n\nexport type MaskInputOptions = Partial<{\n  color: boolean;\n  date: boolean;\n  'datetime-local': boolean;\n  email: boolean;\n  month: boolean;\n  number: boolean;\n  range: boolean;\n  search: boolean;\n  tel: boolean;\n  text: boolean;\n  time: boolean;\n  url: boolean;\n  week: boolean;\n  // unify textarea and select element with text input\n  textarea: boolean;\n  select: boolean;\n}>;\n\nexport type SlimDOMOptions = Partial<{\n  script: boolean;\n  comment: boolean;\n  headFavicon: boolean;\n  headWhitespace: boolean;\n  headMetaDescKeywords: boolean;\n  headMetaSocial: boolean;\n  headMetaRobots: boolean;\n  headMetaHttpEquiv: boolean;\n  headMetaAuthorship: boolean;\n  headMetaVerification: boolean;\n}>;\n","import {\n  serializedNode,\n  serializedNodeWithId,\n  NodeType,\n  attributes,\n  INode,\n  idNodeMap,\n  MaskInputOptions,\n  SlimDOMOptions,\n} from './types';\n\nlet _id = 1;\nconst tagNameRegex = RegExp('[^a-z1-6-_]');\n\nexport const IGNORED_NODE = -2;\n\nfunction genId(): number {\n  return _id++;\n}\n\nfunction getValidTagName(element: HTMLElement): string {\n  if (element instanceof HTMLFormElement) {\n    return 'form';\n  }\n\n  const processedTagName = element.tagName.toLowerCase().trim();\n\n  if (tagNameRegex.test(processedTagName)) {\n    // if the tag name is odd and we cannot extract\n    // anything from the string, then we return a\n    // generic div\n    return 'div';\n  }\n\n  return processedTagName;\n}\n\nfunction getCssRulesString(s: CSSStyleSheet): string | null {\n  try {\n    const rules = s.rules || s.cssRules;\n    return rules ? Array.from(rules).map(getCssRuleString).join('') : null;\n  } catch (error) {\n    return null;\n  }\n}\n\nfunction getCssRuleString(rule: CSSRule): string {\n  return isCSSImportRule(rule)\n    ? getCssRulesString(rule.styleSheet) || ''\n    : rule.cssText;\n}\n\nfunction isCSSImportRule(rule: CSSRule): rule is CSSImportRule {\n  return 'styleSheet' in rule;\n}\n\nfunction extractOrigin(url: string): string {\n  let origin;\n  if (url.indexOf('//') > -1) {\n    origin = url.split('/').slice(0, 3).join('/');\n  } else {\n    origin = url.split('/')[0];\n  }\n  origin = origin.split('?')[0];\n  return origin;\n}\n\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")([^\"]*)\"|([^)]*))\\)/gm;\nconst RELATIVE_PATH = /^(?!www\\.|(?:http|ftp)s?:\\/\\/|[A-Za-z]:\\\\|\\/\\/|#).*/;\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\nexport function absoluteToStylesheet(\n  cssText: string | null,\n  href: string,\n): string {\n  return (cssText || '').replace(\n    URL_IN_CSS_REF,\n    (origin, quote1, path1, quote2, path2, path3) => {\n      const filePath = path1 || path2 || path3;\n      const maybeQuote = quote1 || quote2 || '';\n      if (!filePath) {\n        return origin;\n      }\n      if (!RELATIVE_PATH.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (DATA_URI.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (filePath[0] === '/') {\n        return `url(${maybeQuote}${\n          extractOrigin(href) + filePath\n        }${maybeQuote})`;\n      }\n      const stack = href.split('/');\n      const parts = filePath.split('/');\n      stack.pop();\n      for (const part of parts) {\n        if (part === '.') {\n          continue;\n        } else if (part === '..') {\n          stack.pop();\n        } else {\n          stack.push(part);\n        }\n      }\n      return `url(${maybeQuote}${stack.join('/')}${maybeQuote})`;\n    },\n  );\n}\n\nfunction getAbsoluteSrcsetString(doc: Document, attributeValue: string) {\n  if (attributeValue.trim() === '') {\n    return attributeValue;\n  }\n\n  const srcsetValues = attributeValue.split(',');\n  // srcset attributes is defined as such:\n  // srcset = \"url size,url1 size1\"\n  const resultingSrcsetString = srcsetValues\n    .map((srcItem) => {\n      // removing all but middle spaces\n      const trimmedSrcItem = srcItem.trimLeft().trimRight();\n      const urlAndSize = trimmedSrcItem.split(' ');\n      // this means we have both 0:url and 1:size\n      if (urlAndSize.length === 2) {\n        const absUrl = absoluteToDoc(doc, urlAndSize[0]);\n        return `${absUrl} ${urlAndSize[1]}`;\n      } else if (urlAndSize.length === 1) {\n        const absUrl = absoluteToDoc(doc, urlAndSize[0]);\n        return `${absUrl}`;\n      }\n      return '';\n    })\n    .join(', ');\n\n  return resultingSrcsetString;\n}\n\nexport function absoluteToDoc(doc: Document, attributeValue: string): string {\n  if (!attributeValue || attributeValue.trim() === '') {\n    return attributeValue;\n  }\n  const a: HTMLAnchorElement = doc.createElement('a');\n  a.href = attributeValue;\n  return a.href;\n}\n\nfunction isSVGElement(el: Element): boolean {\n  return el.tagName === 'svg' || el instanceof SVGElement;\n}\n\nexport function transformAttribute(\n  doc: Document,\n  name: string,\n  value: string,\n): string {\n  // relative path in attribute\n  if (name === 'src' || ((name === 'href' || name === 'xlink:href') && value)) {\n    return absoluteToDoc(doc, value);\n  } else if (name === 'srcset' && value) {\n    return getAbsoluteSrcsetString(doc, value);\n  } else if (name === 'style' && value) {\n    return absoluteToStylesheet(value, location.href);\n  } else {\n    return value;\n  }\n}\n\nexport function _isBlockedElement(\n  element: HTMLElement,\n  blockClass: string | RegExp,\n  blockSelector: string | null,\n): boolean {\n  if (typeof blockClass === 'string') {\n    if (element.classList.contains(blockClass)) {\n      return true;\n    }\n  } else {\n    element.classList.forEach((className) => {\n      if (blockClass.test(className)) {\n        return true;\n      }\n    });\n  }\n  if (blockSelector) {\n    return element.matches(blockSelector);\n  }\n\n  return false;\n}\n\nfunction serializeNode(\n  n: Node,\n  options: {\n    doc: Document;\n    blockClass: string | RegExp;\n    blockSelector: string | null;\n    inlineStylesheet: boolean;\n    maskInputOptions: MaskInputOptions;\n    recordCanvas: boolean;\n  },\n): serializedNode | false {\n  const {\n    doc,\n    blockClass,\n    blockSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    recordCanvas,\n  } = options;\n  switch (n.nodeType) {\n    case n.DOCUMENT_NODE:\n      return {\n        type: NodeType.Document,\n        childNodes: [],\n      };\n    case n.DOCUMENT_TYPE_NODE:\n      return {\n        type: NodeType.DocumentType,\n        name: (n as DocumentType).name,\n        publicId: (n as DocumentType).publicId,\n        systemId: (n as DocumentType).systemId,\n      };\n    case n.ELEMENT_NODE:\n      const needBlock = _isBlockedElement(\n        n as HTMLElement,\n        blockClass,\n        blockSelector,\n      );\n      const tagName = getValidTagName(n as HTMLElement);\n      let attributes: attributes = {};\n      for (const { name, value } of Array.from((n as HTMLElement).attributes)) {\n        attributes[name] = transformAttribute(doc, name, value);\n      }\n      // remote css\n      if (tagName === 'link' && inlineStylesheet) {\n        const stylesheet = Array.from(doc.styleSheets).find((s) => {\n          return s.href === (n as HTMLLinkElement).href;\n        });\n        const cssText = getCssRulesString(stylesheet as CSSStyleSheet);\n        if (cssText) {\n          delete attributes.rel;\n          delete attributes.href;\n          attributes._cssText = absoluteToStylesheet(\n            cssText,\n            stylesheet!.href!,\n          );\n        }\n      }\n      // dynamic stylesheet\n      if (\n        tagName === 'style' &&\n        (n as HTMLStyleElement).sheet &&\n        // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n        !(\n          (n as HTMLElement).innerText ||\n          (n as HTMLElement).textContent ||\n          ''\n        ).trim().length\n      ) {\n        const cssText = getCssRulesString(\n          (n as HTMLStyleElement).sheet as CSSStyleSheet,\n        );\n        if (cssText) {\n          attributes._cssText = absoluteToStylesheet(cssText, location.href);\n        }\n      }\n      // form fields\n      if (\n        tagName === 'input' ||\n        tagName === 'textarea' ||\n        tagName === 'select'\n      ) {\n        const value = (n as HTMLInputElement | HTMLTextAreaElement).value;\n        if (\n          attributes.type !== 'radio' &&\n          attributes.type !== 'checkbox' &&\n          attributes.type !== 'submit' &&\n          attributes.type !== 'button' &&\n          value\n        ) {\n          attributes.value =\n            maskInputOptions[attributes.type as keyof MaskInputOptions] ||\n            maskInputOptions[tagName as keyof MaskInputOptions]\n              ? '*'.repeat(value.length)\n              : value;\n        } else if ((n as HTMLInputElement).checked) {\n          attributes.checked = (n as HTMLInputElement).checked;\n        }\n      }\n      if (tagName === 'option') {\n        const selectValue = (n as HTMLOptionElement).parentElement;\n        if (attributes.value === (selectValue as HTMLSelectElement).value) {\n          attributes.selected = (n as HTMLOptionElement).selected;\n        }\n      }\n      // canvas image data\n      if (tagName === 'canvas' && recordCanvas) {\n        attributes.rr_dataURL = (n as HTMLCanvasElement).toDataURL();\n      }\n      // media elements\n      if (tagName === 'audio' || tagName === 'video') {\n        attributes.rr_mediaState = (n as HTMLMediaElement).paused\n          ? 'paused'\n          : 'played';\n      }\n      // scroll\n      if ((n as HTMLElement).scrollLeft) {\n        attributes.rr_scrollLeft = (n as HTMLElement).scrollLeft;\n      }\n      if ((n as HTMLElement).scrollTop) {\n        attributes.rr_scrollTop = (n as HTMLElement).scrollTop;\n      }\n      if (needBlock) {\n        const { width, height } = (n as HTMLElement).getBoundingClientRect();\n        attributes = {\n          class: attributes.class,\n          rr_width: `${width}px`,\n          rr_height: `${height}px`,\n        };\n      }\n      return {\n        type: NodeType.Element,\n        tagName,\n        attributes,\n        childNodes: [],\n        isSVG: isSVGElement(n as Element) || undefined,\n        needBlock,\n      };\n    case n.TEXT_NODE:\n      // The parent node may not be a html element which has a tagName attribute.\n      // So just let it be undefined which is ok in this use case.\n      const parentTagName =\n        n.parentNode && (n.parentNode as HTMLElement).tagName;\n      let textContent = (n as Text).textContent;\n      const isStyle = parentTagName === 'STYLE' ? true : undefined;\n      if (isStyle && textContent) {\n        textContent = absoluteToStylesheet(textContent, location.href);\n      }\n      if (parentTagName === 'SCRIPT') {\n        textContent = 'SCRIPT_PLACEHOLDER';\n      }\n      return {\n        type: NodeType.Text,\n        textContent: textContent || '',\n        isStyle,\n      };\n    case n.CDATA_SECTION_NODE:\n      return {\n        type: NodeType.CDATA,\n        textContent: '',\n      };\n    case n.COMMENT_NODE:\n      return {\n        type: NodeType.Comment,\n        textContent: (n as Comment).textContent || '',\n      };\n    default:\n      return false;\n  }\n}\n\nfunction lowerIfExists(maybeAttr: string | number | boolean): string {\n  if (maybeAttr === undefined) {\n    return '';\n  } else {\n    return (maybeAttr as string).toLowerCase();\n  }\n}\n\nfunction slimDOMExcluded(\n  sn: serializedNode,\n  slimDOMOptions: SlimDOMOptions,\n): boolean {\n  if (slimDOMOptions.comment && sn.type === NodeType.Comment) {\n    // TODO: convert IE conditional comments to real nodes\n    return true;\n  } else if (sn.type === NodeType.Element) {\n    if (\n      slimDOMOptions.script &&\n      (sn.tagName === 'script' ||\n        (sn.tagName === 'link' &&\n          sn.attributes.rel === 'preload' &&\n          sn.attributes.as === 'script'))\n    ) {\n      return true;\n    } else if (\n      slimDOMOptions.headFavicon &&\n      ((sn.tagName === 'link' && sn.attributes.rel === 'shortcut icon') ||\n        (sn.tagName === 'meta' &&\n          (lowerIfExists(sn.attributes.name).match(\n            /^msapplication-tile(image|color)$/,\n          ) ||\n            lowerIfExists(sn.attributes.name) === 'application-name' ||\n            lowerIfExists(sn.attributes.rel) === 'icon' ||\n            lowerIfExists(sn.attributes.rel) === 'apple-touch-icon' ||\n            lowerIfExists(sn.attributes.rel) === 'shortcut icon')))\n    ) {\n      return true;\n    } else if (sn.tagName === 'meta') {\n      if (\n        slimDOMOptions.headMetaDescKeywords &&\n        lowerIfExists(sn.attributes.name).match(/^description|keywords$/)\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaSocial &&\n        (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)\n          lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) ||\n          lowerIfExists(sn.attributes.name) === 'pinterest')\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaRobots &&\n        (lowerIfExists(sn.attributes.name) === 'robots' ||\n          lowerIfExists(sn.attributes.name) === 'googlebot' ||\n          lowerIfExists(sn.attributes.name) === 'bingbot')\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaHttpEquiv &&\n        sn.attributes['http-equiv'] !== undefined\n      ) {\n        // e.g. X-UA-Compatible, Content-Type, Content-Language,\n        // cache-control, X-Translated-By\n        return true;\n      } else if (\n        slimDOMOptions.headMetaAuthorship &&\n        (lowerIfExists(sn.attributes.name) === 'author' ||\n          lowerIfExists(sn.attributes.name) === 'generator' ||\n          lowerIfExists(sn.attributes.name) === 'framework' ||\n          lowerIfExists(sn.attributes.name) === 'publisher' ||\n          lowerIfExists(sn.attributes.name) === 'progid' ||\n          lowerIfExists(sn.attributes.property).match(/^article:/) ||\n          lowerIfExists(sn.attributes.property).match(/^product:/))\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaVerification &&\n        (lowerIfExists(sn.attributes.name) === 'google-site-verification' ||\n          lowerIfExists(sn.attributes.name) === 'yandex-verification' ||\n          lowerIfExists(sn.attributes.name) === 'csrf-token' ||\n          lowerIfExists(sn.attributes.name) === 'p:domain_verify' ||\n          lowerIfExists(sn.attributes.name) === 'verify-v1' ||\n          lowerIfExists(sn.attributes.name) === 'verification' ||\n          lowerIfExists(sn.attributes.name) === 'shopify-checkout-api-token')\n      ) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nexport function serializeNodeWithId(\n  n: Node | INode,\n  options: {\n    doc: Document;\n    map: idNodeMap;\n    blockClass: string | RegExp;\n    blockSelector: string | null;\n    skipChild: boolean;\n    inlineStylesheet: boolean;\n    maskInputOptions?: MaskInputOptions;\n    slimDOMOptions: SlimDOMOptions;\n    recordCanvas?: boolean;\n    preserveWhiteSpace?: boolean;\n  },\n): serializedNodeWithId | null {\n  const {\n    doc,\n    map,\n    blockClass,\n    blockSelector,\n    skipChild = false,\n    inlineStylesheet = true,\n    maskInputOptions = {},\n    slimDOMOptions,\n    recordCanvas = false,\n  } = options;\n  let { preserveWhiteSpace = true } = options;\n  const _serializedNode = serializeNode(n, {\n    doc,\n    blockClass,\n    blockSelector,\n    inlineStylesheet,\n    maskInputOptions,\n    recordCanvas,\n  });\n  if (!_serializedNode) {\n    // TODO: dev only\n    console.warn(n, 'not serialized');\n    return null;\n  }\n\n  let id;\n  // Try to reuse the previous id\n  if ('__sn' in n) {\n    id = n.__sn.id;\n  } else if (\n    slimDOMExcluded(_serializedNode, slimDOMOptions) ||\n    (!preserveWhiteSpace &&\n      _serializedNode.type === NodeType.Text &&\n      !_serializedNode.isStyle &&\n      !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, '').length)\n  ) {\n    id = IGNORED_NODE;\n  } else {\n    id = genId();\n  }\n  const serializedNode = Object.assign(_serializedNode, { id });\n  (n as INode).__sn = serializedNode;\n  if (id === IGNORED_NODE) {\n    return null; // slimDOM\n  }\n  map[id] = n as INode;\n  let recordChild = !skipChild;\n  if (serializedNode.type === NodeType.Element) {\n    recordChild = recordChild && !serializedNode.needBlock;\n    // this property was not needed in replay side\n    delete serializedNode.needBlock;\n  }\n  if (\n    (serializedNode.type === NodeType.Document ||\n      serializedNode.type === NodeType.Element) &&\n    recordChild\n  ) {\n    if (\n      slimDOMOptions.headWhitespace &&\n      _serializedNode.type === NodeType.Element &&\n      _serializedNode.tagName === 'head'\n      // would impede performance: || getComputedStyle(n)['white-space'] === 'normal'\n    ) {\n      preserveWhiteSpace = false;\n    }\n    for (const childN of Array.from(n.childNodes)) {\n      const serializedChildNode = serializeNodeWithId(childN, {\n        doc,\n        map,\n        blockClass,\n        blockSelector,\n        skipChild,\n        inlineStylesheet,\n        maskInputOptions,\n        slimDOMOptions,\n        recordCanvas,\n        preserveWhiteSpace,\n      });\n      if (serializedChildNode) {\n        serializedNode.childNodes.push(serializedChildNode);\n      }\n    }\n  }\n  return serializedNode;\n}\n\nfunction snapshot(\n  n: Document,\n  options?: {\n    blockClass?: string | RegExp;\n    inlineStylesheet?: boolean;\n    maskAllInputs?: boolean | MaskInputOptions;\n    slimDOM?: boolean | SlimDOMOptions;\n    recordCanvas?: boolean;\n    blockSelector?: string | null;\n  },\n): [serializedNodeWithId | null, idNodeMap] {\n  const {\n    blockClass = 'rr-block',\n    inlineStylesheet = true,\n    recordCanvas = false,\n    blockSelector = null,\n    maskAllInputs = false,\n    slimDOM = false,\n  } = options || {};\n  const idNodeMap: idNodeMap = {};\n  const maskInputOptions: MaskInputOptions =\n    maskAllInputs === true\n      ? {\n          color: true,\n          date: true,\n          'datetime-local': true,\n          email: true,\n          month: true,\n          number: true,\n          range: true,\n          search: true,\n          tel: true,\n          text: true,\n          time: true,\n          url: true,\n          week: true,\n          textarea: true,\n          select: true,\n        }\n      : maskAllInputs === false\n      ? {}\n      : maskAllInputs;\n  const slimDOMOptions: SlimDOMOptions =\n    slimDOM === true || slimDOM === 'all'\n      ? // if true: set of sensible options that should not throw away any information\n        {\n          script: true,\n          comment: true,\n          headFavicon: true,\n          headWhitespace: true,\n          headMetaDescKeywords: slimDOM === 'all', // destructive\n          headMetaSocial: true,\n          headMetaRobots: true,\n          headMetaHttpEquiv: true,\n          headMetaAuthorship: true,\n          headMetaVerification: true,\n        }\n      : slimDOM === false\n      ? {}\n      : slimDOM;\n  return [\n    serializeNodeWithId(n, {\n      doc: n,\n      map: idNodeMap,\n      blockClass,\n      blockSelector,\n      skipChild: false,\n      inlineStylesheet,\n      maskInputOptions,\n      slimDOMOptions,\n      recordCanvas,\n    }),\n    idNodeMap,\n  ];\n}\n\nexport function visitSnapshot(\n  node: serializedNodeWithId,\n  onVisit: (node: serializedNodeWithId) => unknown,\n) {\n  function walk(current: serializedNodeWithId) {\n    onVisit(current);\n    if (\n      current.type === NodeType.Document ||\n      current.type === NodeType.Element\n    ) {\n      current.childNodes.forEach(walk);\n    }\n  }\n\n  walk(node);\n}\n\nexport function cleanupSnapshot() {\n  // allow a new recording to start numbering nodes from scratch\n  _id = 1;\n}\n\nexport default snapshot;\n","/**\n * This file is a fork of https://github.com/reworkcss/css/blob/master/lib/parse/index.js\n * I fork it because:\n * 1. The css library was built for node.js which does not have tree-shaking supports.\n * 2. Rewrites into typescript give us a better type interface.\n */\n\n/* tslint:disable no-conditional-assignment interface-name no-shadowed-variable */\n\nexport interface ParserOptions {\n  /** Silently fail on parse errors */\n  silent?: boolean;\n  /**\n   * The path to the file containing css.\n   * Makes errors and source maps more helpful, by letting them know where code comes from.\n   */\n  source?: string;\n}\n\n/**\n * Error thrown during parsing.\n */\nexport interface ParserError {\n  /** The full error message with the source position. */\n  message?: string;\n  /** The error message without position. */\n  reason?: string;\n  /** The value of options.source if passed to css.parse. Otherwise undefined. */\n  filename?: string;\n  line?: number;\n  column?: number;\n  /** The portion of code that couldn't be parsed. */\n  source?: string;\n}\n\nexport interface Loc {\n  line?: number;\n  column?: number;\n}\n\n/**\n * Base AST Tree Node.\n */\nexport interface Node {\n  /** The possible values are the ones listed in the Types section on https://github.com/reworkcss/css page. */\n  type?: string;\n  /** A reference to the parent node, or null if the node has no parent. */\n  parent?: Node;\n  /** Information about the position in the source string that corresponds to the node. */\n  position?: {\n    start?: Loc;\n    end?: Loc;\n    /** The value of options.source if passed to css.parse. Otherwise undefined. */\n    source?: string;\n    /** The full source string passed to css.parse. */\n    content?: string;\n  };\n}\n\nexport interface Rule extends Node {\n  /** The list of selectors of the rule, split on commas. Each selector is trimmed from whitespace and comments. */\n  selectors?: string[];\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\nexport interface Declaration extends Node {\n  /** The property name, trimmed from whitespace and comments. May not be empty. */\n  property?: string;\n  /** The value of the property, trimmed from whitespace and comments. Empty values are allowed. */\n  value?: string;\n}\n\n/**\n * A rule-level or declaration-level comment. Comments inside selectors, properties and values etc. are lost.\n */\nexport interface Comment extends Node {\n  comment?: string;\n}\n\n/**\n * The @charset at-rule.\n */\nexport interface Charset extends Node {\n  /** The part following @charset. */\n  charset?: string;\n}\n\n/**\n * The @custom-media at-rule\n */\nexport interface CustomMedia extends Node {\n  /** The ---prefixed name. */\n  name?: string;\n  /** The part following the name. */\n  media?: string;\n}\n\n/**\n * The @document at-rule.\n */\nexport interface Document extends Node {\n  /** The part following @document. */\n  document?: string;\n  /** The vendor prefix in @document, or undefined if there is none. */\n  vendor?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/**\n * The @font-face at-rule.\n */\nexport interface FontFace extends Node {\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\n/**\n * The @host at-rule.\n */\nexport interface Host extends Node {\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/**\n * The @import at-rule.\n */\nexport interface Import extends Node {\n  /** The part following @import. */\n  import?: string;\n}\n\n/**\n * The @keyframes at-rule.\n */\nexport interface KeyFrames extends Node {\n  /** The name of the keyframes rule. */\n  name?: string;\n  /** The vendor prefix in @keyframes, or undefined if there is none. */\n  vendor?: string;\n  /** Array of nodes with the types keyframe and comment. */\n  keyframes?: Array<KeyFrame | Comment>;\n}\n\nexport interface KeyFrame extends Node {\n  /** The list of \"selectors\" of the keyframe rule, split on commas. Each “selector” is trimmed from whitespace. */\n  values?: string[];\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\n/**\n * The @media at-rule.\n */\nexport interface Media extends Node {\n  /** The part following @media. */\n  media?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/**\n * The @namespace at-rule.\n */\nexport interface Namespace extends Node {\n  /** The part following @namespace. */\n  namespace?: string;\n}\n\n/**\n * The @page at-rule.\n */\nexport interface Page extends Node {\n  /** The list of selectors of the rule, split on commas. Each selector is trimmed from whitespace and comments. */\n  selectors?: string[];\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\n/**\n * The @supports at-rule.\n */\nexport interface Supports extends Node {\n  /** The part following @supports. */\n  supports?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/** All at-rules. */\nexport type AtRule =\n  | Charset\n  | CustomMedia\n  | Document\n  | FontFace\n  | Host\n  | Import\n  | KeyFrames\n  | Media\n  | Namespace\n  | Page\n  | Supports;\n\n/**\n * A collection of rules\n */\nexport interface StyleRules {\n  source?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules: Array<Rule | Comment | AtRule>;\n  /** Array of Errors. Errors collected during parsing when option silent is true. */\n  parsingErrors?: ParserError[];\n}\n\n/**\n * The root node returned by css.parse.\n */\nexport interface Stylesheet extends Node {\n  stylesheet?: StyleRules;\n}\n\n// http://www.w3.org/TR/CSS21/grammar.html\n// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027\nconst commentre = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\n\nexport function parse(css: string, options: ParserOptions = {}) {\n  /**\n   * Positional.\n   */\n\n  let lineno = 1;\n  let column = 1;\n\n  /**\n   * Update lineno and column based on `str`.\n   */\n\n  function updatePosition(str: string) {\n    const lines = str.match(/\\n/g);\n    if (lines) {\n      lineno += lines.length;\n    }\n    let i = str.lastIndexOf('\\n');\n    column = i === -1 ? column + str.length : str.length - i;\n  }\n\n  /**\n   * Mark position and patch `node.position`.\n   */\n\n  function position() {\n    const start = { line: lineno, column };\n    return (\n      node: Rule | Declaration | Comment | AtRule | Stylesheet | KeyFrame,\n    ) => {\n      node.position = new Position(start);\n      whitespace();\n      return node;\n    };\n  }\n\n  /**\n   * Store position information for a node\n   */\n\n  class Position {\n    public content!: string;\n    public start!: Loc;\n    public end!: Loc;\n    public source?: string;\n\n    constructor(start: Loc) {\n      this.start = start;\n      this.end = { line: lineno, column };\n      this.source = options.source;\n    }\n  }\n\n  /**\n   * Non-enumerable source string\n   */\n\n  Position.prototype.content = css;\n\n  const errorsList: ParserError[] = [];\n\n  function error(msg: string) {\n    const err = new Error(\n      options.source + ':' + lineno + ':' + column + ': ' + msg,\n    ) as ParserError;\n    err.reason = msg;\n    err.filename = options.source;\n    err.line = lineno;\n    err.column = column;\n    err.source = css;\n\n    if (options.silent) {\n      errorsList.push(err);\n    } else {\n      throw err;\n    }\n  }\n\n  /**\n   * Parse stylesheet.\n   */\n\n  function stylesheet(): Stylesheet {\n    const rulesList = rules();\n\n    return {\n      type: 'stylesheet',\n      stylesheet: {\n        source: options.source,\n        rules: rulesList,\n        parsingErrors: errorsList,\n      },\n    };\n  }\n\n  /**\n   * Opening brace.\n   */\n\n  function open() {\n    return match(/^{\\s*/);\n  }\n\n  /**\n   * Closing brace.\n   */\n\n  function close() {\n    return match(/^}/);\n  }\n\n  /**\n   * Parse ruleset.\n   */\n\n  function rules() {\n    let node: Rule | void;\n    const rules: Rule[] = [];\n    whitespace();\n    comments(rules);\n    while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {\n      if (node !== false) {\n        rules.push(node);\n        comments(rules);\n      }\n    }\n    return rules;\n  }\n\n  /**\n   * Match `re` and return captures.\n   */\n\n  function match(re: RegExp) {\n    const m = re.exec(css);\n    if (!m) {\n      return;\n    }\n    const str = m[0];\n    updatePosition(str);\n    css = css.slice(str.length);\n    return m;\n  }\n\n  /**\n   * Parse whitespace.\n   */\n\n  function whitespace() {\n    match(/^\\s*/);\n  }\n\n  /**\n   * Parse comments;\n   */\n\n  function comments(rules: Rule[] = []) {\n    let c: Comment | void;\n    while ((c = comment())) {\n      if (c !== false) {\n        rules.push(c);\n      }\n      c = comment();\n    }\n    return rules;\n  }\n\n  /**\n   * Parse comment.\n   */\n\n  function comment() {\n    const pos = position();\n    if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) {\n      return;\n    }\n\n    let i = 2;\n    while (\n      '' !== css.charAt(i) &&\n      ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1))\n    ) {\n      ++i;\n    }\n    i += 2;\n\n    if ('' === css.charAt(i - 1)) {\n      return error('End of comment missing');\n    }\n\n    const str = css.slice(2, i - 2);\n    column += 2;\n    updatePosition(str);\n    css = css.slice(i);\n    column += 2;\n\n    return pos({\n      type: 'comment',\n      comment: str,\n    });\n  }\n\n  /**\n   * Parse selector.\n   */\n\n  function selector() {\n    const m = match(/^([^{]+)/);\n    if (!m) {\n      return;\n    }\n    /* @fix Remove all comments from selectors\n     * http://ostermiller.org/findcomment.html */\n    return trim(m[0])\n      .replace(/\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*\\/+/g, '')\n      .replace(/\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'/g, (m) => {\n        return m.replace(/,/g, '\\u200C');\n      })\n      .split(/\\s*(?![^(]*\\)),\\s*/)\n      .map((s) => {\n        return s.replace(/\\u200C/g, ',');\n      });\n  }\n\n  /**\n   * Parse declaration.\n   */\n\n  function declaration(): Declaration | void | never {\n    const pos = position();\n\n    // prop\n    let propMatch = match(/^(\\*?[-#\\/\\*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/);\n    if (!propMatch) {\n      return;\n    }\n    const prop = trim(propMatch[0]);\n\n    // :\n    if (!match(/^:\\s*/)) {\n      return error(`property missing ':'`);\n    }\n\n    // val\n    const val = match(/^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+)/);\n\n    const ret = pos({\n      type: 'declaration',\n      property: prop.replace(commentre, ''),\n      value: val ? trim(val[0]).replace(commentre, '') : '',\n    });\n\n    // ;\n    match(/^[;\\s]*/);\n\n    return ret;\n  }\n\n  /**\n   * Parse declarations.\n   */\n\n  function declarations() {\n    const decls: Array<object> = [];\n\n    if (!open()) {\n      return error(`missing '{'`);\n    }\n    comments(decls);\n\n    // declarations\n    let decl;\n    while ((decl = declaration())) {\n      if ((decl as unknown) !== false) {\n        decls.push(decl);\n        comments(decls);\n      }\n      decl = declaration();\n    }\n\n    if (!close()) {\n      return error(`missing '}'`);\n    }\n    return decls;\n  }\n\n  /**\n   * Parse keyframe.\n   */\n\n  function keyframe() {\n    let m;\n    const vals = [];\n    const pos = position();\n\n    while ((m = match(/^((\\d+\\.\\d+|\\.\\d+|\\d+)%?|[a-z]+)\\s*/))) {\n      vals.push(m[1]);\n      match(/^,\\s*/);\n    }\n\n    if (!vals.length) {\n      return;\n    }\n\n    return pos({\n      type: 'keyframe',\n      values: vals,\n      declarations: declarations() as Declaration[],\n    });\n  }\n\n  /**\n   * Parse keyframes.\n   */\n\n  function atkeyframes() {\n    const pos = position();\n    let m = match(/^@([-\\w]+)?keyframes\\s*/);\n\n    if (!m) {\n      return;\n    }\n    const vendor = m[1];\n\n    // identifier\n    m = match(/^([-\\w]+)\\s*/);\n    if (!m) {\n      return error('@keyframes missing name');\n    }\n    const name = m[1];\n\n    if (!open()) {\n      return error(`@keyframes missing '{'`);\n    }\n\n    let frame;\n    let frames = comments();\n    while ((frame = keyframe())) {\n      frames.push(frame);\n      frames = frames.concat(comments());\n    }\n\n    if (!close()) {\n      return error(`@keyframes missing '}'`);\n    }\n\n    return pos({\n      type: 'keyframes',\n      name,\n      vendor,\n      keyframes: frames,\n    });\n  }\n\n  /**\n   * Parse supports.\n   */\n\n  function atsupports() {\n    const pos = position();\n    const m = match(/^@supports *([^{]+)/);\n\n    if (!m) {\n      return;\n    }\n    const supports = trim(m[1]);\n\n    if (!open()) {\n      return error(`@supports missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@supports missing '}'`);\n    }\n\n    return pos({\n      type: 'supports',\n      supports,\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse host.\n   */\n\n  function athost() {\n    const pos = position();\n    const m = match(/^@host\\s*/);\n\n    if (!m) {\n      return;\n    }\n\n    if (!open()) {\n      return error(`@host missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@host missing '}'`);\n    }\n\n    return pos({\n      type: 'host',\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse media.\n   */\n\n  function atmedia() {\n    const pos = position();\n    const m = match(/^@media *([^{]+)/);\n\n    if (!m) {\n      return;\n    }\n    const media = trim(m[1]);\n\n    if (!open()) {\n      return error(`@media missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@media missing '}'`);\n    }\n\n    return pos({\n      type: 'media',\n      media,\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse custom-media.\n   */\n\n  function atcustommedia() {\n    const pos = position();\n    const m = match(/^@custom-media\\s+(--[^\\s]+)\\s*([^{;]+);/);\n    if (!m) {\n      return;\n    }\n\n    return pos({\n      type: 'custom-media',\n      name: trim(m[1]),\n      media: trim(m[2]),\n    });\n  }\n\n  /**\n   * Parse paged media.\n   */\n\n  function atpage() {\n    const pos = position();\n    const m = match(/^@page */);\n    if (!m) {\n      return;\n    }\n\n    const sel = selector() || [];\n\n    if (!open()) {\n      return error(`@page missing '{'`);\n    }\n    let decls = comments();\n\n    // declarations\n    let decl;\n    while ((decl = declaration())) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n\n    if (!close()) {\n      return error(`@page missing '}'`);\n    }\n\n    return pos({\n      type: 'page',\n      selectors: sel,\n      declarations: decls,\n    });\n  }\n\n  /**\n   * Parse document.\n   */\n\n  function atdocument() {\n    const pos = position();\n    const m = match(/^@([-\\w]+)?document *([^{]+)/);\n    if (!m) {\n      return;\n    }\n\n    const vendor = trim(m[1]);\n    const doc = trim(m[2]);\n\n    if (!open()) {\n      return error(`@document missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@document missing '}'`);\n    }\n\n    return pos({\n      type: 'document',\n      document: doc,\n      vendor,\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse font-face.\n   */\n\n  function atfontface() {\n    const pos = position();\n    const m = match(/^@font-face\\s*/);\n    if (!m) {\n      return;\n    }\n\n    if (!open()) {\n      return error(`@font-face missing '{'`);\n    }\n    let decls = comments();\n\n    // declarations\n    let decl;\n    while ((decl = declaration())) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n\n    if (!close()) {\n      return error(`@font-face missing '}'`);\n    }\n\n    return pos({\n      type: 'font-face',\n      declarations: decls,\n    });\n  }\n\n  /**\n   * Parse import\n   */\n\n  const atimport = _compileAtrule('import');\n\n  /**\n   * Parse charset\n   */\n\n  const atcharset = _compileAtrule('charset');\n\n  /**\n   * Parse namespace\n   */\n\n  const atnamespace = _compileAtrule('namespace');\n\n  /**\n   * Parse non-block at-rules\n   */\n\n  function _compileAtrule(name: string) {\n    const re = new RegExp('^@' + name + '\\\\s*([^;]+);');\n    return () => {\n      const pos = position();\n      const m = match(re);\n      if (!m) {\n        return;\n      }\n      const ret: Record<string, string> = { type: name };\n      ret[name] = m[1].trim();\n      return pos(ret);\n    };\n  }\n\n  /**\n   * Parse at rule.\n   */\n\n  function atrule() {\n    if (css[0] !== '@') {\n      return;\n    }\n\n    return (\n      atkeyframes() ||\n      atmedia() ||\n      atcustommedia() ||\n      atsupports() ||\n      atimport() ||\n      atcharset() ||\n      atnamespace() ||\n      atdocument() ||\n      atpage() ||\n      athost() ||\n      atfontface()\n    );\n  }\n\n  /**\n   * Parse rule.\n   */\n\n  function rule() {\n    const pos = position();\n    const sel = selector();\n\n    if (!sel) {\n      return error('selector missing');\n    }\n    comments();\n\n    return pos({\n      type: 'rule',\n      selectors: sel,\n      declarations: declarations() as Declaration[],\n    });\n  }\n\n  return addParent(stylesheet());\n}\n\n/**\n * Trim `str`.\n */\n\nfunction trim(str: string) {\n  return str ? str.replace(/^\\s+|\\s+$/g, '') : '';\n}\n\n/**\n * Adds non-enumerable parent node reference to each node.\n */\n\nfunction addParent(obj: Stylesheet, parent?: Stylesheet) {\n  const isNode = obj && typeof obj.type === 'string';\n  const childParent = isNode ? obj : parent;\n\n  for (const k of Object.keys(obj)) {\n    const value = obj[k as keyof Stylesheet];\n    if (Array.isArray(value)) {\n      value.forEach((v) => {\n        addParent(v, childParent);\n      });\n    } else if (value && typeof value === 'object') {\n      addParent((value as unknown) as Stylesheet, childParent);\n    }\n  }\n\n  if (isNode) {\n    Object.defineProperty(obj, 'parent', {\n      configurable: true,\n      writable: true,\n      enumerable: false,\n      value: parent || null,\n    });\n  }\n\n  return obj;\n}\n","import { parse } from './css';\nimport {\n  serializedNodeWithId,\n  NodeType,\n  tagMap,\n  elementNode,\n  idNodeMap,\n  INode,\n} from './types';\n\nconst tagMap: tagMap = {\n  script: 'noscript',\n  // camel case svg element tag names\n  altglyph: 'altGlyph',\n  altglyphdef: 'altGlyphDef',\n  altglyphitem: 'altGlyphItem',\n  animatecolor: 'animateColor',\n  animatemotion: 'animateMotion',\n  animatetransform: 'animateTransform',\n  clippath: 'clipPath',\n  feblend: 'feBlend',\n  fecolormatrix: 'feColorMatrix',\n  fecomponenttransfer: 'feComponentTransfer',\n  fecomposite: 'feComposite',\n  feconvolvematrix: 'feConvolveMatrix',\n  fediffuselighting: 'feDiffuseLighting',\n  fedisplacementmap: 'feDisplacementMap',\n  fedistantlight: 'feDistantLight',\n  fedropshadow: 'feDropShadow',\n  feflood: 'feFlood',\n  fefunca: 'feFuncA',\n  fefuncb: 'feFuncB',\n  fefuncg: 'feFuncG',\n  fefuncr: 'feFuncR',\n  fegaussianblur: 'feGaussianBlur',\n  feimage: 'feImage',\n  femerge: 'feMerge',\n  femergenode: 'feMergeNode',\n  femorphology: 'feMorphology',\n  feoffset: 'feOffset',\n  fepointlight: 'fePointLight',\n  fespecularlighting: 'feSpecularLighting',\n  fespotlight: 'feSpotLight',\n  fetile: 'feTile',\n  feturbulence: 'feTurbulence',\n  foreignobject: 'foreignObject',\n  glyphref: 'glyphRef',\n  lineargradient: 'linearGradient',\n  radialgradient: 'radialGradient',\n};\nfunction getTagName(n: elementNode): string {\n  let tagName = tagMap[n.tagName] ? tagMap[n.tagName] : n.tagName;\n  if (tagName === 'link' && n.attributes._cssText) {\n    tagName = 'style';\n  }\n  return tagName;\n}\n\nconst HOVER_SELECTOR = /([^\\\\]):hover/g;\nexport function addHoverClass(cssText: string): string {\n  const ast = parse(cssText, { silent: true });\n  if (!ast.stylesheet) {\n    return cssText;\n  }\n  ast.stylesheet.rules.forEach((rule) => {\n    if ('selectors' in rule) {\n      (rule.selectors || []).forEach((selector: string) => {\n        if (HOVER_SELECTOR.test(selector)) {\n          const newSelector = selector.replace(HOVER_SELECTOR, '$1.\\\\:hover');\n          cssText = cssText.replace(selector, `${selector}, ${newSelector}`);\n        }\n      });\n    }\n  });\n  return cssText;\n}\n\nfunction buildNode(\n  n: serializedNodeWithId,\n  options: {\n    doc: Document;\n    hackCss: boolean;\n  },\n): Node | null {\n  const { doc, hackCss } = options;\n  switch (n.type) {\n    case NodeType.Document:\n      return doc.implementation.createDocument(null, '', null);\n    case NodeType.DocumentType:\n      return doc.implementation.createDocumentType(\n        n.name || 'html',\n        n.publicId,\n        n.systemId,\n      );\n    case NodeType.Element:\n      const tagName = getTagName(n);\n      let node: Element;\n      if (n.isSVG) {\n        node = doc.createElementNS('http://www.w3.org/2000/svg', tagName);\n      } else {\n        node = doc.createElement(tagName);\n      }\n      for (const name in n.attributes) {\n        if (!n.attributes.hasOwnProperty(name)) {\n          continue;\n        }\n        let value = n.attributes[name];\n        value =\n          typeof value === 'boolean' || typeof value === 'number' ? '' : value;\n        // attribute names start with rr_ are internal attributes added by rrweb\n        if (!name.startsWith('rr_')) {\n          const isTextarea = tagName === 'textarea' && name === 'value';\n          const isRemoteOrDynamicCss =\n            tagName === 'style' && name === '_cssText';\n          if (isRemoteOrDynamicCss && hackCss) {\n            value = addHoverClass(value);\n          }\n          if (isTextarea || isRemoteOrDynamicCss) {\n            const child = doc.createTextNode(value);\n            // https://github.com/rrweb-io/rrweb/issues/112\n            for (const c of Array.from(node.childNodes)) {\n              if (c.nodeType === node.TEXT_NODE) {\n                node.removeChild(c);\n              }\n            }\n            node.appendChild(child);\n            continue;\n          }\n          if (tagName === 'iframe' && name === 'src') {\n            continue;\n          }\n          try {\n            if (n.isSVG && name === 'xlink:href') {\n              node.setAttributeNS('http://www.w3.org/1999/xlink', name, value);\n            } else if (\n              name === 'onload' ||\n              name === 'onclick' ||\n              name.substring(0, 7) === 'onmouse'\n            ) {\n              // Rename some of the more common atttributes from https://www.w3schools.com/tags/ref_eventattributes.asp\n              // as setting them triggers a console.error (which shows up despite the try/catch)\n              // Assumption: these attributes are not used to css\n              node.setAttribute('_' + name, value);\n            } else {\n              node.setAttribute(name, value);\n            }\n          } catch (error) {\n            // skip invalid attribute\n          }\n        } else {\n          // handle internal attributes\n          if (tagName === 'canvas' && name === 'rr_dataURL') {\n            const image = document.createElement('img');\n            image.src = value;\n            image.onload = () => {\n              const ctx = (node as HTMLCanvasElement).getContext('2d');\n              if (ctx) {\n                ctx.drawImage(image, 0, 0, image.width, image.height);\n              }\n            };\n          }\n          if (name === 'rr_width') {\n            (node as HTMLElement).style.width = value;\n          }\n          if (name === 'rr_height') {\n            (node as HTMLElement).style.height = value;\n          }\n          if (name === 'rr_mediaState') {\n            switch (value) {\n              case 'played':\n                (node as HTMLMediaElement).play();\n              case 'paused':\n                (node as HTMLMediaElement).pause();\n                break;\n              default:\n            }\n          }\n        }\n      }\n      return node;\n    case NodeType.Text:\n      return doc.createTextNode(\n        n.isStyle && hackCss ? addHoverClass(n.textContent) : n.textContent,\n      );\n    case NodeType.CDATA:\n      return doc.createCDATASection(n.textContent);\n    case NodeType.Comment:\n      return doc.createComment(n.textContent);\n    default:\n      return null;\n  }\n}\n\nexport function buildNodeWithSN(\n  n: serializedNodeWithId,\n  options: {\n    doc: Document;\n    map: idNodeMap;\n    skipChild?: boolean;\n    hackCss: boolean;\n  },\n): INode | null {\n  const { doc, map, skipChild = false, hackCss = true } = options;\n  let node = buildNode(n, { doc, hackCss });\n  if (!node) {\n    return null;\n  }\n  // use target document as root document\n  if (n.type === NodeType.Document) {\n    // close before open to make sure document was closed\n    doc.close();\n    doc.open();\n    node = doc;\n  }\n\n  (node as INode).__sn = n;\n  map[n.id] = node as INode;\n  if (\n    (n.type === NodeType.Document || n.type === NodeType.Element) &&\n    !skipChild\n  ) {\n    for (const childN of n.childNodes) {\n      const childNode = buildNodeWithSN(childN, {\n        doc,\n        map,\n        skipChild: false,\n        hackCss,\n      });\n      if (!childNode) {\n        console.warn('Failed to rebuild', childN);\n      } else {\n        node.appendChild(childNode);\n      }\n    }\n  }\n  return node as INode;\n}\n\nfunction visit(idNodeMap: idNodeMap, onVisit: (node: INode) => void) {\n  function walk(node: INode) {\n    onVisit(node);\n  }\n\n  for (const key in idNodeMap) {\n    if (idNodeMap[key]) {\n      walk(idNodeMap[key]);\n    }\n  }\n}\n\nfunction handleScroll(node: INode) {\n  const n = node.__sn;\n  if (n.type !== NodeType.Element) {\n    return;\n  }\n  const el = (node as Node) as HTMLElement;\n  for (const name in n.attributes) {\n    if (!(n.attributes.hasOwnProperty(name) && name.startsWith('rr_'))) {\n      continue;\n    }\n    const value = n.attributes[name];\n    if (name === 'rr_scrollLeft') {\n      el.scrollLeft = value as number;\n    }\n    if (name === 'rr_scrollTop') {\n      el.scrollTop = value as number;\n    }\n  }\n}\n\nfunction rebuild(\n  n: serializedNodeWithId,\n  options: {\n    doc: Document;\n    onVisit?: (node: INode) => unknown;\n    hackCss?: boolean;\n  },\n): [Node | null, idNodeMap] {\n  const { doc, onVisit, hackCss = true } = options;\n  const idNodeMap: idNodeMap = {};\n  const node = buildNodeWithSN(n, {\n    doc,\n    map: idNodeMap,\n    skipChild: false,\n    hackCss,\n  });\n  visit(idNodeMap, (visitedNode) => {\n    if (onVisit) {\n      onVisit(visitedNode);\n    }\n    handleScroll(visitedNode);\n  });\n  return [node, idNodeMap];\n}\n\nexport default rebuild;\n"],"names":["NodeType","_id","tagNameRegex","RegExp","IGNORED_NODE","genId","getValidTagName","element","HTMLFormElement","processedTagName","tagName","toLowerCase","trim","test","getCssRulesString","s","rules","cssRules","Array","from","map","getCssRuleString","join","error","rule","isCSSImportRule","styleSheet","cssText","extractOrigin","url","indexOf","split","slice","URL_IN_CSS_REF","RELATIVE_PATH","DATA_URI","absoluteToStylesheet","href","replace","origin","quote1","path1","quote2","path2","path3","filePath","maybeQuote","stack","parts","pop","parts_1","_i","part","push","getAbsoluteSrcsetString","doc","attributeValue","srcItem","urlAndSize","trimLeft","trimRight","length","absoluteToDoc","a","createElement","isSVGElement","el","SVGElement","transformAttribute","name","value","location","_isBlockedElement","blockClass","blockSelector","classList","contains","forEach","className","matches","serializeNode","n","options","inlineStylesheet","_a","maskInputOptions","recordCanvas","nodeType","DOCUMENT_NODE","type","Document","childNodes","DOCUMENT_TYPE_NODE","DocumentType","publicId","systemId","ELEMENT_NODE","needBlock","attributes_1","_b","attributes","_c","stylesheet","styleSheets","find","rel","_cssText","sheet","innerText","textContent","repeat","checked","selectValue","parentElement","selected","rr_dataURL","toDataURL","rr_mediaState","paused","scrollLeft","rr_scrollLeft","scrollTop","rr_scrollTop","_d","getBoundingClientRect","width","height","class","rr_width","rr_height","Element","isSVG","undefined","TEXT_NODE","parentTagName","parentNode","isStyle","Text","CDATA_SECTION_NODE","CDATA","COMMENT_NODE","Comment","lowerIfExists","maybeAttr","slimDOMExcluded","sn","slimDOMOptions","comment","script","as","headFavicon","match","headMetaDescKeywords","headMetaSocial","property","headMetaRobots","headMetaHttpEquiv","headMetaAuthorship","headMetaVerification","serializeNodeWithId","id","skipChild","_e","preserveWhiteSpace","_serializedNode","console","warn","__sn","serializedNode","Object","assign","recordChild","headWhitespace","_f","serializedChildNode","snapshot","maskAllInputs","_g","slimDOM","idNodeMap","color","date","datetime-local","email","month","number","range","search","tel","text","time","week","textarea","select","visitSnapshot","node","onVisit","walk","current","cleanupSnapshot","commentre","parse","css","lineno","column","updatePosition","str","lines","i","lastIndexOf","position","start","line","Position","whitespace","this","end","source","prototype","content","errorsList","msg","err","Error","reason","filename","silent","open","close","comments","charAt","atrule","re","m","exec","c","pos","selector","declaration","propMatch","prop","val","ret","declarations","decl","decls","keyframe","vals","values","rulesList","atimport","_compileAtrule","atcharset","atnamespace","vendor","frame","frames","concat","keyframes","atkeyframes","media","style","atmedia","atcustommedia","supports","atsupports","document","atdocument","sel","selectors","atpage","athost","atfontface","addParent","parsingErrors","obj","parent","isNode","childParent","keys","isArray","v","defineProperty","configurable","writable","enumerable","tagMap","altglyph","altglyphdef","altglyphitem","animatecolor","animatemotion","animatetransform","clippath","feblend","fecolormatrix","fecomponenttransfer","fecomposite","feconvolvematrix","fediffuselighting","fedisplacementmap","fedistantlight","fedropshadow","feflood","fefunca","fefuncb","fefuncg","fefuncr","fegaussianblur","feimage","femerge","femergenode","femorphology","feoffset","fepointlight","fespecularlighting","fespotlight","fetile","feturbulence","foreignobject","glyphref","lineargradient","radialgradient","getTagName","HOVER_SELECTOR","addHoverClass","ast","newSelector","buildNode","hackCss","implementation","createDocument","createDocumentType","node_1","createElementNS","hasOwnProperty","startsWith","image_1","src","onload","ctx","getContext","drawImage","play","pause","isTextarea","isRemoteOrDynamicCss","child","createTextNode","removeChild","appendChild","setAttributeNS","substring","setAttribute","createCDATASection","createComment","buildNodeWithSN","childN","childNode","visit","key","handleScroll","rebuild","visitedNode"],"mappings":"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"}